{
  "topic": "算法基础",
  "content": [
    {
      "id": "algorithm-intro",
      "title": "算法概述",
      "content": "算法是解决特定问题的一系列明确指令或步骤。一个好的算法通常具有以下特性：正确性（能够解决指定问题）、确定性（每一步操作都是明确的）、有限性（在有限步骤后终止）、可行性（步骤可以被执行）和效率（时间和空间资源消耗合理）。算法分析关注算法的效率，通常使用大O表示法（O(n)、O(log n)、O(n²)等）来描述算法的时间和空间复杂度，其中n表示输入规模。算法设计范式包括分治法、动态规划、贪心算法、回溯法等。算法是计算机科学的核心，为软件开发和问题解决提供了理论基础。"
    },
    {
      "id": "complexity-analysis",
      "title": "复杂度分析",
      "content": "复杂度分析用于评估算法效率，主要分为时间复杂度和空间复杂度。时间复杂度测量算法执行所需的时间（或基本操作数），空间复杂度测量算法所需的内存空间。大O表示法是描述算法复杂度的标准方式，表示算法在最坏情况下的上界。常见的时间复杂度从高效到低效依次为：O(1)（常数时间）、O(log n)（对数时间）、O(n)（线性时间）、O(n log n)、O(n²)、O(n³)、O(2^n)、O(n!)。此外，还有平均复杂度和最佳复杂度分析。复杂度分析帮助我们理解算法在大规模数据处理时的表现，是算法设计和选择的重要依据。低阶项通常在分析中被忽略，因为当输入规模足够大时，高阶项的影响占主导地位。"
    },
    {
      "id": "sorting-algorithms",
      "title": "排序算法",
      "content": "排序算法用于将一组数据元素重新排列成特定顺序（通常是升序或降序）。常见的排序算法包括：冒泡排序（相邻元素比较交换，O(n²)）；插入排序（将元素插入已排序部分，O(n²)）；选择排序（每次选择最小元素，O(n²)）；快速排序（分治法，平均O(n log n)，最坏O(n²)）；归并排序（分治法，稳定O(n log n)）；堆排序（使用堆数据结构，O(n log n)）；计数排序（适用于有限范围整数，O(n+k)）；桶排序和基数排序（适用于特定分布的数据）。排序算法的选择取决于数据规模、分布特性、稳定性要求和可用内存等因素。稳定排序算法（如冒泡、插入、归并排序）保持相等元素的相对顺序，而非稳定排序算法（如快速排序、堆排序）可能改变相等元素的相对顺序。"
    },
    {
      "id": "searching-algorithms",
      "title": "搜索算法",
      "content": "搜索算法用于在数据集中查找特定元素。线性搜索（顺序检查每个元素，O(n)）适用于无序数据；二分搜索（要求有序数据，O(log n)）通过不断将搜索范围减半来提高效率；散列查找（哈希表，平均O(1)）通过键值映射实现快速查找，但可能面临冲突处理问题；二叉搜索树查找（平均O(log n)，最坏O(n)）结合了排序和树形结构的优势；插值搜索（O(log log n)，适用于均匀分布数据）是二分搜索的改进版本。图搜索算法包括深度优先搜索（DFS，使用栈或递归）和广度优先搜索（BFS，使用队列），用于在图结构中寻找路径或探索连通性。搜索算法的选择取决于数据结构、数据是否有序、预期搜索频率和时间效率需求。"
    },
    {
      "id": "graph-algorithms",
      "title": "图算法",
      "content": "图算法处理由节点（顶点）和边组成的图结构。广度优先搜索（BFS）使用队列，适合寻找最短路径；深度优先搜索（DFS）使用栈或递归，适合探索所有可能路径、拓扑排序和连通性分析。最短路径算法包括：Dijkstra算法（单源最短路径，不适用于负权边）；Bellman-Ford算法（可处理负权边，检测负权回路）；Floyd-Warshall算法（所有顶点对之间的最短路径）。最小生成树算法包括Kruskal算法（按边权重排序）和Prim算法（从单一顶点扩展），用于寻找连接图中所有顶点的最小权重边集合。拓扑排序用于有向无环图（DAG），确定依赖关系的处理顺序。强连通分量算法（如Kosaraju算法和Tarjan算法）用于识别有向图中的强连通子图。图算法在社交网络分析、路由系统、调度问题和计算机网络中有广泛应用。"
    },
    {
      "id": "dynamic-programming",
      "title": "动态规划",
      "content": "动态规划（DP）是一种通过将复杂问题分解为重叠子问题并存储子问题解来优化计算的算法设计范式。动态规划适用于具有最优子结构（问题的最优解包含子问题的最优解）和重叠子问题（相同子问题多次出现）特性的问题。实现动态规划有两种主要方法：自顶向下（递归+记忆化）和自底向上（迭代填表）。经典动态规划问题包括：斐波那契数列计算（从O(2^n)优化到O(n)）；最长公共子序列（LCS，用于字符串比较）；0-1背包问题（物品选择最大化价值）；最优二叉搜索树；矩阵链乘法；最长递增子序列（LIS）；编辑距离（字符串转换最小操作数）；硬币找零问题。动态规划通过消除重复计算，将指数级时间复杂度问题优化到多项式级别，在优化、图论、生物信息学和机器学习等领域有广泛应用。"
    },
    {
      "id": "greedy-algorithms",
      "title": "贪心算法",
      "content": "贪心算法是一种在每步做出当前最优选择的策略，希望最终得到全局最优解的方法。贪心算法易于设计和实现，通常效率高，但不总是能得到最优解。贪心算法适用的问题需满足贪心选择性质（局部最优选择导致全局最优解）和最优子结构性质（最优解包含子问题的最优解）。经典贪心算法包括：活动选择问题（最大化兼容活动数量）；霍夫曼编码（最优前缀编码）；最小生成树算法（Kruskal和Prim）；Dijkstra单源最短路径算法；分数背包问题（可部分选择物品）；任务调度（最小化完成时间或延迟）。贪心算法在某些问题（如0-1背包）上可能失效，此时需要动态规划等其他方法。贪心算法的正确性通常通过数学归纳法或反证法证明，证明过程需要证明局部最优选择导致全局最优解。"
    },
    {
      "id": "divide-conquer",
      "title": "分治法",
      "content": "分治法（Divide and Conquer）是一种将复杂问题分解为相似但规模更小的子问题，独立解决后合并结果的算法设计范式。分治法的基本步骤包括：分解（将原问题分解为子问题）、解决（递归解决子问题）和合并（将子问题的解组合形成原问题的解）。典型的分治算法包括：归并排序（将数组分成两半，分别排序后合并，O(n log n)）；快速排序（选择基准元素，分区，递归排序，平均O(n log n)）；Karatsuba大整数乘法（将n位整数乘法分解为三个n/2位整数乘法）；Strassen矩阵乘法（将n×n矩阵乘法从8个子矩阵乘法减少到7个）；最近点对问题；快速傅里叶变换（FFT）。分治法的优势在于可以利用递归思想简化复杂问题，并且适合并行计算；缺点是可能产生大量重复计算（此时可结合动态规划），并且递归实现可能带来栈溢出风险。"
    },
    {
      "id": "backtracking",
      "title": "回溯法",
      "content": "回溯法是一种系统地搜索问题解空间的算法策略，通过尝试部分解决方案并在发现不满足约束条件时"回溯"到上一步继续探索。回溯法适用于组合优化问题，特别是约束满足问题和列举所有可能解的情况。回溯算法通常使用递归实现，包含三个关键步骤：选择（做出一个选择）、约束（检查是否满足问题约束）和回溯（若不满足则撤销选择并尝试下一个）。经典回溯问题包括：N皇后问题（在N×N棋盘上放置N个皇后使它们互不攻击）；数独求解；图着色问题；汉密尔顿路径问题；子集和问题；组合生成（如全排列、所有子集）；迷宫路径查找。回溯法的效率可通过剪枝技术提高，即提前识别和排除不可能产生有效解的路径。回溯法的时间复杂度通常较高（可能是指数级），但在许多没有多项式时间算法的问题上是最实用的方法。"
    },
    {
      "id": "string-algorithms",
      "title": "字符串算法",
      "content": "字符串算法专门处理文本数据，是文本编辑、生物信息学和网络搜索等领域的基础。字符串匹配算法用于在文本中查找模式，包括：朴素算法（暴力匹配，O(mn)，m是模式长度，n是文本长度）；KMP算法（利用部分匹配表避免不必要比较，O(m+n)）；Boyer-Moore算法（从右向左比较，利用坏字符和好后缀规则跳过比较，最好O(n/m)）；Rabin-Karp算法（使用哈希函数，适合多模式匹配）。字符串处理算法包括：最长公共子序列/子串；最小编辑距离（Levenshtein距离）；字符串压缩（如霍夫曼编码、LZ77）；回文检测和构造；字符串排序（如基数排序、后缀数组）；正则表达式匹配（有限状态机）。高级数据结构如后缀树、后缀数组和Trie树在字符串处理中发挥重要作用。字符串算法在全文搜索、拼写检查、生物序列比对和数据压缩等应用中尤为重要。"
    },
    {
      "id": "computational-geometry",
      "title": "计算几何",
      "content": "计算几何是研究几何问题的算法和数据结构的领域。基本操作包括点的表示、线段相交判定和凸包计算。凸包算法（如Graham扫描和Jarvis行进，O(n log n)）用于计算包含所有给定点的最小凸多边形。点对最近距离问题可通过分治法在O(n log n)时间内解决。几何搜索结构包括：k-d树（用于多维空间点的快速检索）；区域树（range tree，支持区间查询）；四叉树（2D空间分割）和八叉树（3D空间分割）。计算几何算法还包括：Delaunay三角剖分（最大化最小角）；Voronoi图（划分空间为最近点区域）；线段相交检测（扫描线算法）；多边形三角剖分；点在多边形内的判定；多边形面积计算。计算几何在计算机图形学、地理信息系统（GIS）、机器人路径规划、VLSI设计和计算机辅助设计（CAD）中有广泛应用。解决计算几何问题需要注意数值精度和特殊情况（如共线点和退化情况）的处理。"
    },
    {
      "id": "randomized-algorithms",
      "title": "随机算法",
      "content": "随机算法是利用随机性来设计和分析的算法，通过引入概率元素来获得效率或简洁性。随机算法分为：拉斯维加斯算法（总是返回正确结果，运行时间随机）和蒙特卡洛算法（固定运行时间，但可能返回近似结果）。典型随机算法包括：随机快速排序（随机选择基准元素，期望时间O(n log n)）；Karger最小割算法（通过随机合并顶点找最小割）；Miller-Rabin素性测试（概率性判断大数是否为素数）；蒙特卡洛积分法（随机采样估算定积分）；随机化线性检查（用于相等性测试）；随机采样和蓄水池抽样算法（从数据流中等概率抽取样本）。随机算法的优势在于简单性和效率，某些问题上比确定性算法表现更好。分析随机算法时关注期望性能和失败概率，而非最坏情况。随机算法在密码学、数值计算、优化问题和机器学习中有重要应用，常作为确定性算法的有效替代。"
    },
    {
      "id": "approximation-algorithms",
      "title": "近似算法",
      "content": "近似算法针对NP难问题，在多项式时间内找到近似最优解。近似比是算法解与最优解的比值，用于衡量近似算法的质量。对于最小化问题，近似比≥1（越接近1越好）；对于最大化问题，近似比≤1（越接近1越好）。常见近似算法包括：旅行商问题（TSP）的2-近似算法（使用最小生成树）；顶点覆盖问题的2-近似算法；集合覆盖问题的ln(n)-近似贪心算法；装箱问题的First-Fit和Best-Fit算法；MAX-SAT问题的随机化近似算法；MAX-CUT问题的0.878-近似算法（基于半正定规划）。近似算法设计技术包括贪心法、局部搜索、线性规划放松和舍入、动态规划近似等。近似方案（approximation scheme）是参数化的算法族，如PTAS（多项式时间近似方案）和FPTAS（完全多项式时间近似方案），允许用户在运行时间和精度间权衡。近似算法在图论、调度、网络设计和组合优化中有广泛应用。"
    },
    {
      "id": "parallel-algorithms",
      "title": "并行算法",
      "content": "并行算法设计用于在多处理器环境下同时执行多个计算步骤，以提高处理速度和效率。并行算法分析关注工作量（总计算步骤）、深度/关键路径长度（最长顺序执行路径）和处理器效率。基本并行范式包括：数据并行（同一操作应用于不同数据）；任务并行（不同处理器执行不同任务）；流水线并行（任务分为多个阶段顺序执行）。并行算法设计考虑负载均衡（工作在处理器间均匀分配）、通信开销最小化和数据依赖管理。经典并行算法包括：并行前缀和（scan，O(log n)深度）；并行归并排序和快速排序；并行矩阵乘法（Cannon算法、DNS算法）；并行图算法（如并行BFS和最短路径）；并行动态规划；MapReduce框架（大规模数据处理）。并行算法面临的挑战包括线程同步、数据竞争、死锁和通信延迟。并行计算模型包括PRAM（并行随机访问机）、消息传递和共享内存模型。并行算法在高性能计算、大数据处理、科学模拟和实时系统中越来越重要。"
    }
  ]
} 