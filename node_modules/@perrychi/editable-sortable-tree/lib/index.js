'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var antd = require('antd');
var lodash = require('lodash');
var icons = require('@ant-design/icons');
var he = require('he');
require('antd/dist/antd.css');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var MenuNode = function MenuNode(props) {
  var onEdit = props.onEdit,
      _props$nodeInfo = props.nodeInfo,
      _props$nodeInfo$title = _props$nodeInfo.title,
      nodeTextInit = _props$nodeInfo$title === void 0 ? '' : _props$nodeInfo$title,
      _props$nodeInfo$key = _props$nodeInfo.key,
      key = _props$nodeInfo$key === void 0 ? '' : _props$nodeInfo$key,
      onSave = props.onSave,
      onAdd = props.onAdd,
      onDelete = props.onDelete,
      onSelectNode = props.onSelectNode,
      setCurrentSelectNode = props.setCurrentSelectNode,
      isTreeUnderEditing = props.isTreeUnderEditing,
      setTreeUnderEditing = props.setTreeUnderEditing,
      getValidateResult = props.getValidateResult,
      editingNode = props.editingNode,
      setEditingNode = props.setEditingNode; // console.log('24 editingNode', editingNode);
  // 当前节点是否可编辑

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isCurrentNodeEditable = _useState2[0],
      setCurrentNodeEditable = _useState2[1];

  var _useState3 = React.useState(nodeTextInit),
      _useState4 = _slicedToArray(_useState3, 2),
      nodeText = _useState4[0],
      setNodeText = _useState4[1];

  var _useState5 = React.useState(0),
      _useState6 = _slicedToArray(_useState5, 2),
      editTimestamp = _useState6[0],
      setEditTimestamp = _useState6[1];

  var nodeInputRef = React.useRef(null); // console.log('31 isCurrentNodeEditable', key, isCurrentNodeEditable);

  React.useEffect(function () {
    // 整个页面监听click，如果点击了，则让组件树由编辑状态变为展示状态
    document.addEventListener('click', function (event) {
      var targetClassName = event.target.className; // if (!targetClassName) {
      //   setCurrentNodeEditable(false);
      // }

      if (targetClassName && typeof targetClassName === 'string' && !targetClassName.includes('nodeInput')) {
        // setEditingNode清除 正在编辑中的节点
        setEditingNode('');
        setCurrentNodeEditable(false);
        setTreeUnderEditing(false);
      }
    }, true);
  }, []); // 当正在编辑的节点切换了，则实时设置节点的状态

  React.useEffect(function () {
    if (editingNode) {
      // console.log('53 editingNode', key, editingNode);
      // 将触发了编辑事件的节点设置为 编辑状态
      setCurrentNodeEditable(key === editingNode);
      setTimeout(function () {
        if (nodeInputRef && nodeInputRef.current) {
          // 让节点的input框中的内容自动选中方便替换
          nodeInputRef.current.select();
        }
      }, 200);
    }
  }, [editingNode, editTimestamp]); // 点击了 菜单节点的文字

  var selectNode = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var validateResult;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return getValidateResult();

            case 2:
              validateResult = _context.sent;

              // console.log('69 key', key, validateResult);
              if (validateResult) {
                // 将点击的节点设置为Tree当前选中的节点
                setCurrentSelectNode(key); // 选中当前节点后需要处理一些事情

                onSelectNode(key);
              }

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function selectNode() {
      return _ref.apply(this, arguments);
    };
  }(); // 点击 菜单节点后的加号图标


  var addNewMenuNode = function addNewMenuNode() {
    onAdd(key);
  }; // 去编辑菜单节点


  var edit = function edit() {
    // 将触发了编辑的节点id传给回调函数
    onEdit(key); // 让editTimestamp发生变化，并监听，参见52行useEffect

    setEditTimestamp(Date.now());
  }; // 菜单节点名称input框的值改变了


  var nodeChange = function nodeChange(event) {
    setNodeText(event.target.value);
  }; // 保存菜单节点名称的修改


  var saveNode = function saveNode() {
    // console.log('97 key', key);
    setCurrentNodeEditable(false);
    onSave(key, nodeText);
    setTreeUnderEditing(false);
    setCurrentSelectNode(key); // setEditingNode清除 正在编辑中的节点

    setEditingNode('');
  }; // 监听按键事件，当按下回车键时保存节点名称


  document.onkeydown = function (e) {
    // 兼容FF、IE和Opera
    var event = e || window.event;

    if (isCurrentNodeEditable && event.code === 'Enter') {
      // 保存菜单节点的修改
      saveNode();
    }
  }; // 点击 菜单节点后的删除图标


  var deleteMenuNode = function deleteMenuNode() {
    onDelete(key);
  };

  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, !isCurrentNodeEditable ?
  /*#__PURE__*/
  // 当前Tree节点不可编辑时，用span展示节点名称
  React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("span", {
    className: "nodeText",
    onClick: selectNode
  }, nodeText), key.includes('-') && !isTreeUnderEditing && /*#__PURE__*/React__default["default"].createElement(icons.EditOutlined, {
    className: "iconGap",
    onClick: edit
  }), !isTreeUnderEditing && /*#__PURE__*/React__default["default"].createElement(icons.PlusOutlined, {
    className: "iconGap",
    onClick: addNewMenuNode
  }), key.includes('-') && !isTreeUnderEditing && /*#__PURE__*/React__default["default"].createElement(antd.Popconfirm, {
    title: "Are you sure you want to delete menu \"".concat(nodeText, "\"?"),
    onConfirm: deleteMenuNode,
    okText: "Yes",
    cancelText: "Cancel"
  }, !isTreeUnderEditing && /*#__PURE__*/React__default["default"].createElement(icons.DeleteOutlined, null))) :
  /*#__PURE__*/
  // 当前Tree节点可编辑时，用input输入框编辑节点名称
  React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement(antd.Input, {
    className: "nodeInput",
    value: nodeText,
    size: "small",
    onChange: nodeChange,
    ref: nodeInputRef
  }), /*#__PURE__*/React__default["default"].createElement(icons.CheckOutlined, {
    className: "saveNode",
    onClick: saveNode
  })));
};

var debounce = function debounce(callback) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
  var timerId = null;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (timerId) {
      clearTimeout(timerId);
    }

    timerId = setTimeout(function () {
      callback.apply(void 0, args);
    }, delay);
  };
}; // 深层递归将对象字段中的null值替换为undefined，方便解构赋值时对变量赋默认值

var trimNull = function trimNull(object) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$nullValues = _ref.nullValues,
      nullValues = _ref$nullValues === void 0 ? true : _ref$nullValues,
      _ref$escape = _ref.escape,
      escape = _ref$escape === void 0 ? true : _ref$escape;

  return lodash.transform(object, function (result, value, key) {
    // Exclude specific keys.
    // Recurse into arrays and objects.
    if (Array.isArray(value) || lodash.isPlainObject(value)) {
      value = trimNull(value, {
        nullValues: nullValues,
        escape: escape
      });
    } // Exclude null values.


    if (nullValues && value === null) {
      value = undefined;
    } // unescape


    if (escape && typeof value === 'string') {
      // value = unescape(value);
      value = he.unescape(value);
    }

    result[key] = value;
  });
};

var MenuConfigForm = function MenuConfigForm(props) {
  var form = props.form,
      setFieldsValue = props.form.setFieldsValue,
      _props$currentSelectN = props.currentSelectNode,
      currentSelectNode = _props$currentSelectN === void 0 ? '' : _props$currentSelectN,
      updateCurrNodeCode = props.updateCurrNodeCode,
      _props$currentNodeCon = props.currentNodeContent,
      currentNodeContent = _props$currentNodeCon === void 0 ? {} : _props$currentNodeCon,
      treeNodeFormAPI = props.treeNodeFormAPI,
      FormComponent = props.FormComponent; // console.log('29 currentNodeContent', currentNodeContent);

  var _trimNull = trimNull(currentNodeContent || {}),
      _trimNull$key = _trimNull.key,
      key = _trimNull$key === void 0 ? '' : _trimNull$key,
      _trimNull$title = _trimNull.title,
      name = _trimNull$title === void 0 ? '' : _trimNull$title,
      _trimNull$code = _trimNull.code,
      code = _trimNull$code === void 0 ? '' : _trimNull$code; // 表单项是否必须


  var requiredFlag = currentSelectNode && currentSelectNode !== 'root'; // console.log('34 componentValue', componentValue);
  // console.log('35 iframeUrlValue', iframeUrlValue);
  // 先创建带有防抖特性的查询函数
  // 不可将debounce(updateCurrNodeCode, 500)直接放入onChange函数的执行体中
  // 否则debounce会每次执行，使timerId每次重新赋值为null而无法清除定时器，从而无法达到防抖效果

  var updateCurrNodeCodeWithDebounce = debounce(updateCurrNodeCode, 500); // 当左侧菜单树节点切换时，要在右侧表单中回显菜单节点的各个字段

  React.useEffect(function () {
    // console.log('40 rest', rest);
    setFieldsValue({
      name: name,
      code: code
    }); // treeNodeFormAPI.setFieldsValue({...rest});
  }, [key, name, code]); // 节点组件
  // const formComponent = FormComponent ? FormComponent(currentNodeContent): '';

  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement(antd.Form, {
    form: form,
    labelAlign: "right",
    labelCol: {
      span: 6
    },
    wrapperCol: {
      span: 18
    }
  }, /*#__PURE__*/React__default["default"].createElement(antd.Form.Item, {
    label: "node name",
    name: "name",
    rules: [{
      required: requiredFlag,
      message: 'Please enter node name'
    }],
    initialValue: ""
  }, /*#__PURE__*/React__default["default"].createElement(antd.Input, {
    disabled: true,
    placeholder: "Please edit this node name in the left tree node"
  })), /*#__PURE__*/React__default["default"].createElement(antd.Form.Item, {
    label: "node code",
    name: "code",
    rules: [{
      required: requiredFlag,
      message: 'Please enter node code'
    }],
    initialValue: ""
  }, /*#__PURE__*/React__default["default"].createElement(antd.Input, {
    placeholder: "Please enter node code",
    disabled: currentSelectNode === 'root',
    onChange: function onChange(event) {
      updateCurrNodeCodeWithDebounce(event.target.value);
    }
  }))), !!FormComponent && /*#__PURE__*/React__default["default"].createElement(FormComponent, {
    currentNodeContent: currentNodeContent,
    treeNodeFormAPI: treeNodeFormAPI
  }));
};

var recurse = function recurse(data, key, callback) {
  data.forEach(function (item, index) {
    if (item.key === key) {
      return callback(item, index, data);
    }

    if (item.children) {
      recurse(item.children, key, callback);
    } // 这句可以不需要，主要是为了规避eslint报错：Expected to return a value at the end of arrow function


    return 0;
  }); // 这句可以不需要，主要是为了规避eslint报错：Expected to return a value at the end of arrow function

  return data;
}; // 从前端静态路由文件生成默认路由

var sortHandle = function sortHandle(treeData) {
  treeData.forEach(function (menuNode) {
    var children = menuNode.children;

    if (children) {
      children.sort(function (prev, curr) {
        return prev.menuOrder - curr.menuOrder;
      });
      sortHandle(children);
    }
  });
  return treeData;
}; // 菜单展示时，对各级菜单按照menuOrder排序

var appendFirstLevelMenuToRootNodeChildren = function appendFirstLevelMenuToRootNodeChildren(routesParam) {
  // console.log('87 routesParam', routesParam);
  // const routesData = cloneDeep(trimNull(routesParam));
  // const rootNode = cloneDeep(routesData[0]) || {};
  var rootNode = {
    title: 'rootNode',
    key: 'root',
    code: 'root',
    children: []
  };
  var treeData = [rootNode];
  routesParam.forEach(function () {
    var menuNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (Object.keys(menuNode).length) {
      treeData[0].children.push(menuNode);
    }
  }); // console.log('92 treeData', treeData);

  return treeData;
}; // 对路由数据 添加key、name、menuOrder、children

var addMenuCodeToMenuNode = function addMenuCodeToMenuNode() {
  var treeData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var parentMenuKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'root';
  treeData.forEach(function (node) {
    var title = node.title,
        name = node.name,
        key = node.key,
        code = node.code,
        children = node.children; // 新增节点是没有code的，则取它的key中的最后一级

    var codeTemp = code ? code : key === null || key === void 0 ? void 0 : key.slice((key === null || key === void 0 ? void 0 : key.lastIndexOf('-')) + 1);
    var keyTemp = code === 'root' ? 'root' : "".concat(parentMenuKey, "-").concat(codeTemp); // console.log('107 node', node);

    node.name = title;
    node.key = keyTemp;
    node.title = title || name || code;

    if (children) {
      addMenuCodeToMenuNode(children, keyTemp);
    }
  });
}; // 移除 iframe页节点 和 错误页节点，弹框中的菜单树不需要展示iframe页节点 和 错误页节点

var handleRouteData = function handleRouteData(routesParam) {
  // console.log('56 routesParam', routesParam);
  var routes = appendFirstLevelMenuToRootNodeChildren(routesParam); // console.log('115 routes', routes);

  addMenuCodeToMenuNode(routes); // removeIframeNodeAndErrorPageNode(routes);

  var finalTreeData = sortHandle(routes); // console.log('138', finalTreeData);

  return finalTreeData;
}; // 修改菜单数据中的字段名称，将title改为name，将children改为routes

var modifySomePropertyNameInTreeData = function modifySomePropertyNameInTreeData() {
  var routes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  routes.forEach(function (route, index) {
    var key = route.key,
        title = route.title,
        children = route.children;
    route.name = title;
    delete route.title;
    route.menuOrder = index;

    if (children) {
      route.routes = children;
      modifySomePropertyNameInTreeData(route.routes, key);
      delete route.children;
    }
  });
  return routes;
}; // 获取选中的菜单节点的 内容（菜单名称、code、组件路径等等）

var getCurrentMenuContent = function getCurrentMenuContent(treeData, currentMenuSelected) {
  // console.log('89 treeData', treeData);
  // console.log('90 currentMenuSelected', currentMenuSelected);
  var currentMenuContent = {};

  (function findMenuContent(routes, currentMenuKey) {
    routes.forEach(function (route) {
      var key = route.key,
          children = route.children;

      if (currentMenuKey === key) {
        currentMenuContent = route;
      } else if (children) {
        findMenuContent(children, currentMenuKey);
      }
    });
  })(treeData, currentMenuSelected);

  return lodash.cloneDeep(currentMenuContent);
}; // 将菜单节点信息回显到表单中(后来将节点信息传到表单组件中进行回显，这个函数暂时没用到)

var getNodeInfoFromFormAndUpdateTreeData = function getNodeInfoFromFormAndUpdateTreeData() {
  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  var menuTreeData = params[0],
      currentSelectNodeId = params[1],
      getFieldsValue = params[2],
      treeNodeFormAPI = params[3]; // console.log('218 menuTreeData', menuTreeData);
  // console.log('215 getFieldsValue()', currentSelectNodeId);
  // 如果当前未选中任何节点（一般是当打开弹窗时），不需要获取表单数据来更新节点数据，直接返回原菜单数据

  if (!currentSelectNodeId) {
    return menuTreeData;
  }

  var menuTreeDataTemp = lodash.cloneDeep(menuTreeData);
  var isRootNode = currentSelectNodeId === 'root';
  var parentMenuKey = '';
  var key = ''; // 从组件内置的表单中获取编辑好的节点名称和节点id

  var _getFieldsValue = getFieldsValue(),
      name = _getFieldsValue.name,
      code = _getFieldsValue.code; // 获取用户自定义的节点字段


  var restNodeAttr = null;

  if (treeNodeFormAPI !== null && treeNodeFormAPI !== void 0 && treeNodeFormAPI.getFieldsValue) {
    restNodeAttr = treeNodeFormAPI.getFieldsValue();
  } // 根节点不需要编辑修改


  if (isRootNode) {
    parentMenuKey = 'root';
    key = 'root';
  } else {
    // 截取上个被选中的菜单的父id，以便为它拼接新的id
    parentMenuKey = currentSelectNodeId.slice(0, currentSelectNodeId.lastIndexOf('-')); // 拼接新的菜单id，兜底处理：如果code没有填写则用原来的id（code是必填项，正常不会有这种群情况）

    key = code ? "".concat(parentMenuKey, "-").concat(code) : currentSelectNodeId;
  } // console.log('213 currentSelectNodeId', currentSelectNodeId);
  // console.log('214 key', key);
  // console.log('215 getFieldsValue()', getFieldsValue());
  // 更新节点信息，更新tree数据


  recurse(menuTreeDataTemp, currentSelectNodeId, function (item, index, data) {
    data[index] = _objectSpread2(_objectSpread2({}, item), {}, {
      // 根路由的name和code恒定不变，不需要用表单数据更新
      title: isRootNode ? 'rootNode' : name,
      code: isRootNode ? '/' : code,
      key: key
    }, restNodeAttr);
  }); // console.log('233 menuTreeDataTemp', menuTreeDataTemp);

  return menuTreeDataTemp;
}; // 将多层树形JSON扁平化为一层List

var flatMenuData = function flatMenuData(menuData) {
  var menuList = [];

  (function traverse(routes) {
    routes.forEach(function (route) {
      // console.log('36 route', route);
      var children = route.children;

      var menuItem = _objectSpread2({}, route);

      delete menuItem.children;
      menuList.push(menuItem);

      if (children) {
        traverse(children);
      }
    });
  })(menuData); // console.log('92 menuList', menuList);


  return menuList;
};

var DynamicMenuConfig = function DynamicMenuConfig(props) {
  var form = props.form,
      _props$form = props.form,
      validateFields = _props$form.validateFields,
      getFieldsValue = _props$form.getFieldsValue,
      setFieldsValue = _props$form.setFieldsValue,
      resetFields = _props$form.resetFields,
      isTreeUnderEditing = props.isTreeUnderEditing,
      setTreeUnderEditing = props.setTreeUnderEditing,
      currentSelectNode = props.currentSelectNode,
      setCurrentSelectNode = props.setCurrentSelectNode,
      currentNodeContent = props.currentNodeContent,
      setCurrentNodeContent = props.setCurrentNodeContent,
      editingNode = props.editingNode,
      setEditingNode = props.setEditingNode,
      menuTreeData = props.menuTreeData,
      setMenuTreeData = props.setMenuTreeData,
      treeNodeFormAPI = props.treeNodeFormAPI,
      FormComponent = props.FormComponent,
      leftWidth = props.leftWidth,
      onChange = props.onChange; // console.log('36 props', props);
  // todo: 暂时放在父组件里了，但是有违开闭原则，需要优化，当前被选中的菜单节点（是数组，Tree组件要用）
  // const [currentSelectNode, setCurrentSelectNode] = useState('');
  // 正在编辑名称的菜单节点
  // const [editingNode, setEditingNode] = useState('');
  // 设置Tree组件中展开的节点

  var _useState = React.useState(['root']),
      _useState2 = _slicedToArray(_useState, 2),
      expandedMenuNode = _useState2[0],
      setExpandedMenuNode = _useState2[1]; // 获取 校验表单是否通过，返回true/false


  var getValidateResult = function getValidateResult() {
    return new Promise(function (resolve) {
      validateFields().then(function () {
        resolve(true);
      })["catch"](function () {
        antd.message.warning('Please configure the currently selected node first');
        resolve(false);
      });
    });
  }; // 点击选中了 一个菜单节点


  var onSelectNode = function onSelectNode(key) {
    // console.log('71 currentSelectNode', currentSelectNode);
    // console.log('70 key', key);
    // 点击了节点文字，则选中当前节点
    if (key && currentSelectNode) {
      // 被选中的节点由A切换到了B，则更新A节点的信息
      var menuTreeDataTemp = getNodeInfoFromFormAndUpdateTreeData(menuTreeData, currentSelectNode, getFieldsValue, treeNodeFormAPI);
      setMenuTreeData(menuTreeDataTemp);
    } // 获取被点的节点的信息


    var currentNodeContent = getCurrentMenuContent(menuTreeData, key); // console.log('81 currentNodeContent', currentNodeContent);
    // 将被点击的节点的信息回显到表单上
    // displayNodeInfoInForm(currentMenuContent, setFieldsValue);

    setCurrentNodeContent(currentNodeContent);
  }; // tree节点处于编辑状态时，点击了正在编辑的节点input框后的保存图标，则保存菜单名称


  var saveNode = function saveNode(menuKey, nodeText) {
    // console.log('62 menuKey', menuKey, nodeText);
    // menuKey是保存的节点key，nodeText是编辑后端的节点名称
    // 从右侧表单中获取code
    var _getFieldsValue = getFieldsValue(),
        code = _getFieldsValue.code;

    var menuTreeDataTemp = lodash.cloneDeep(menuTreeData); // currentNodeContent 是被保存了的菜单节点的信息

    var currentNodeContent = null;
    recurse(menuTreeDataTemp, menuKey, function (item, index, data) {
      // 递归判断到菜单树数据中的这个menuKey，更新这个节点的菜单名称和code
      data[index] = _objectSpread2(_objectSpread2({}, item), {}, {
        title: nodeText,
        name: nodeText,
        code: code
      });
      currentNodeContent = _objectSpread2(_objectSpread2({}, item), {}, {
        title: nodeText,
        name: nodeText
      });
    });
    console.log('67 menuTreeDataTemp', menuTreeDataTemp); // 点击了输入框后的保存图标，更新Tree组件数据源，并将该节点信息回显到表单

    setMenuTreeData(menuTreeDataTemp);
    setCurrentNodeContent(currentNodeContent);
  }; // 添加新的菜单节点


  var addNode = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(menuKey) {
      var menuTreeDataTemp, timestamp, keyOfNewNode;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              console.log('64 menuKey', menuKey);
              console.log('99 menuTreeData', menuTreeData);
              _context.next = 4;
              return getValidateResult();

            case 4:
              if (!_context.sent) {
                _context.next = 15;
                break;
              }

              // 获取表单数据并更新正在选中的节点内容，返回新的菜单数据
              menuTreeDataTemp = getNodeInfoFromFormAndUpdateTreeData(menuTreeData, currentSelectNode, getFieldsValue, treeNodeFormAPI); // console.log('74 menuKey', menuKey, currentSelectNode);

              timestamp = Date.now();
              keyOfNewNode = "".concat(menuKey, "-newNode").concat(timestamp);
              console.log('109 menuTreeDataTemp', menuTreeDataTemp);
              recurse(menuTreeDataTemp, menuKey, function (item) {
                // console.log('81 item', item);
                // 创建新节点对象
                var newMemuNode = {
                  title: 'new node',
                  key: keyOfNewNode
                };

                if (!(item.children && Array.isArray(item.children))) {
                  item.children = [];
                } // 将新的节点添加到它的父节点下


                item.children.push(newMemuNode);
              }); // console.log('125 menuTreeDataTemp', menuTreeDataTemp);

              setMenuTreeData(menuTreeDataTemp); // 展开添加新节点的父节点

              setExpandedMenuNode([].concat(_toConsumableArray(expandedMenuNode), [menuKey])); // 自动选中刚才新建的节点

              setCurrentSelectNode(keyOfNewNode); // todo：要注明这两个resetFields的区别
              // 新增节点后 清空右侧的表单内容

              resetFields();
              treeNodeFormAPI === null || treeNodeFormAPI === void 0 ? void 0 : treeNodeFormAPI.resetFields();

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function addNode(_x) {
      return _ref.apply(this, arguments);
    };
  }(); // 编辑菜单节点


  var editNode = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(menuKey) {
      var validateResult;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              console.log('45 menuKey', menuKey);
              console.log('95 currentSelectNode', currentSelectNode);

              if (!(menuKey !== currentSelectNode)) {
                _context2.next = 8;
                break;
              }

              _context2.next = 5;
              return getValidateResult();

            case 5:
              validateResult = _context2.sent;

              if (validateResult) {
                _context2.next = 8;
                break;
              }

              return _context2.abrupt("return");

            case 8:
              onSelectNode(menuKey); // console.log('46 validateResult', validateResult);

              setCurrentSelectNode(menuKey);
              setEditingNode(menuKey); // 整个树组件处于编辑状态,非编辑的节点隐藏编辑、增加、删除图标

              setTreeUnderEditing(true);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function editNode(_x2) {
      return _ref2.apply(this, arguments);
    };
  }(); // 添加新的菜单节点


  var deleteNode = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(menuKey) {
      var validateResult, menuDataCopy;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              validateResult = true; // 如果点击删除图标的节点不是被正在选中的节点，需要先验证正在选中的节点的是否已完成必填项
              // 必须先填写完成选中的节点，菜单删除别的节点

              if (!(menuKey !== currentSelectNode)) {
                _context3.next = 5;
                break;
              }

              _context3.next = 4;
              return getValidateResult();

            case 4:
              validateResult = _context3.sent;

            case 5:
              // console.log('189 menuTreeData', menuTreeData);
              if (validateResult) {
                menuDataCopy = lodash.cloneDeep(menuTreeData); // console.log('192 menuDataCopy', menuDataCopy);

                recurse(menuDataCopy, menuKey, function (_, index, data) {
                  // console.log('72 item', item);
                  // console.log('73 index', index);
                  // console.log('74 data', data);
                  data.splice(index, 1);
                }); // console.log('199 menuDataCopy', menuDataCopy);

                resetFields();
                treeNodeFormAPI === null || treeNodeFormAPI === void 0 ? void 0 : treeNodeFormAPI.resetFields();
                setCurrentSelectNode('');
                setMenuTreeData(menuDataCopy);
              }

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function deleteNode(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();

  var nodeProps = {
    currentSelectNode: currentSelectNode,
    setCurrentSelectNode: setCurrentSelectNode,
    onSave: saveNode,
    onAdd: addNode,
    onEdit: editNode,
    onDelete: deleteNode,
    onSelectNode: onSelectNode,
    isTreeUnderEditing: isTreeUnderEditing,
    setTreeUnderEditing: setTreeUnderEditing,
    getValidateResult: getValidateResult,
    editingNode: editingNode,
    setEditingNode: setEditingNode
  }; // Tree节点渲染逻辑

  var nodeRender = function nodeRender(nodeInfo, currentSelectNodeKey) {
    return /*#__PURE__*/React__default["default"].createElement(MenuNode, _objectSpread2(_objectSpread2({}, nodeProps), {}, {
      nodeInfo: nodeInfo,
      currentSelectNodeKey: currentSelectNodeKey
    }));
  }; // 点击Tree组件节点前的小三角，展开当前节点


  var onExpand = function onExpand(expandedMenuNodeKey) {
    // console.log('180 expandedMenuNodeId', expandedMenuNodeId);
    setExpandedMenuNode(expandedMenuNodeKey);
  }; // 拖拽节点进行 菜单排序


  var onDrop = function onDrop(info) {
    // console.log('196 info', info);
    var dragKey = info.dragNode.key;
    var dropKey = info.node.key;
    var dropPos = info.node.pos.split('-');
    var dropPosition = info.dropPosition - Number(dropPos[dropPos.length - 1]);
    var dropToGap = info.dropToGap;
    var dragParentKey = dragKey.slice(0, dragKey.lastIndexOf('-'));
    var dropParentKey = dropKey.slice(0, dropKey.lastIndexOf('-')); // console.log('242 dragParentKey', dragParentKey, dropParentKey);
    // 跨层级或跨父级拖拽了，则禁止
    // TODO： 是否支持跨级拖拽

    if (dropToGap && dragParentKey !== dropParentKey || !dropToGap && dragParentKey !== dropKey) {
      antd.message.warning('Only supports drag-and-drop sorting between menus at the same level');
      return;
    }

    var data = lodash.cloneDeep(menuTreeData); // Find dragObject

    var dragObj;
    recurse(data, dragKey, function (item, index, arr) {
      arr.splice(index, 1);
      dragObj = item;
    });

    if (!dropToGap) {
      // console.log('220 dropParentKey', info);
      // Drop on the content
      recurse(data, dropKey, function (item) {
        item.children = item.children || []; // where to insert 示例添加到头部，可以是随意位置

        item.children.unshift(dragObj);
      });
    } else if ((info.node.children || []).length > 0 && // Has children
    info.node.expanded && // Is expanded
    dropPosition === 1 // On the bottom gap
    ) {
      // console.log('232 dropParentKey', info);
      recurse(data, dropKey, function (item) {
        item.children = item.children || []; // where to insert 示例添加到头部，可以是随意位置

        item.children.unshift(dragObj); // in previous version, we use item.children.push(dragObj) to insert the
        // item to the tail of the children
      });
    } else {
      // console.log('279 dropParentKey', info);
      var ar;
      var i;
      recurse(data, dropKey, function (item, index, arr) {
        ar = arr;
        i = index;
      });

      if (dropPosition === -1) {
        ar.splice(i, 0, dragObj);
      } else {
        ar.splice(i + 1, 0, dragObj);
      }
    } // console.log('257 data', data);


    setMenuTreeData(data);
  };

  var updateCurrNodeCode = function updateCurrNodeCode(codeString) {
    // console.log('318 currentSelectNode', currentSelectNode);
    var menuTreeDataTemp = lodash.cloneDeep(menuTreeData);

    var _getFieldsValue2 = getFieldsValue(['name']),
        _getFieldsValue2$curr = _getFieldsValue2.currentCodeInputValue,
        currentCodeInputValue = _getFieldsValue2$curr === void 0 ? '' : _getFieldsValue2$curr; // console.log('308 currentCodeInputValue', currentCodeInputValue);
    // 根路由不需要修改


    if (currentSelectNode !== 'root') {
      // console.log('322 codeString', codeString);
      var parentMenuKey = currentSelectNode.slice(0, currentSelectNode.lastIndexOf('-'));
      var key = codeString ? "".concat(parentMenuKey, "-").concat(codeString) : currentSelectNode; // 更新节点信息，更新tree数据

      recurse(menuTreeDataTemp, currentSelectNode, function (item, index, data) {
        var siblingsNodeKeys = data.reduce(function (arr, curr, indx) {
          return indx !== index ? arr.concat(curr.key) : arr;
        }, []); // console.log('315 siblingsNodeKeys', siblingsNodeKeys);

        if (siblingsNodeKeys.includes(key)) {
          antd.message.warning('The same nodeCode already exists in the same level, and the code of the nodes at the same level cannot be the same');
          setFieldsValue({
            code: currentCodeInputValue || ''
          });
        } else {
          data[index] = _objectSpread2(_objectSpread2({}, item), {}, {
            key: key,
            code: codeString
          }); // console.log('333 menuTreeDataTemp', menuTreeDataTemp);

          setCurrentSelectNode(key);
        }
      });
    }

    setMenuTreeData(menuTreeDataTemp);
  }; // console.log('342 menuTreeData', menuTreeData);


  React.useEffect(function () {
    if (onChange && typeof onChange === 'function') {
      onChange(menuTreeData);
    }
  }, [onChange, menuTreeData]);
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: "menuConfig"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "menuTreeContainer",
    style: {
      width: "".concat(typeof leftWidth === 'number' ? leftWidth : 40, "%")
    }
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "menuTreeTitle"
  }, "Tree configuration"), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "menuTree",
    id: "menuTree"
  }, /*#__PURE__*/React__default["default"].createElement(antd.Tree, {
    height: 645 // 虚拟滚动
    ,
    className: "draggable-tree",
    treeData: menuTreeData,
    draggable: !isTreeUnderEditing,
    expandedKeys: expandedMenuNode,
    defaultExpandAll: true,
    onExpand: onExpand,
    onDrop: onDrop,
    titleRender: function titleRender(node) {
      return nodeRender(node, currentSelectNode);
    },
    selectedKeys: [currentSelectNode] // defaultExpandedKeys={this.state.expandedKeys}
    // allowDrop={allowDrop}
    // onDragEnter={this.onDragEnter}

  }))), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "menuContent",
    style: {
      width: "".concat(typeof leftWidth === 'number' ? 100 - leftWidth : 40, "%")
    }
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "menuContentTitle"
  }, "Node details configuration"), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "meneConfigForm"
  }, /*#__PURE__*/React__default["default"].createElement(MenuConfigForm, {
    form: form,
    currentSelectNode: currentSelectNode,
    currentNodeContent: currentNodeContent,
    updateCurrNodeCode: updateCurrNodeCode,
    treeNodeFormAPI: treeNodeFormAPI,
    FormComponent: FormComponent
  }))));
};

// TODO：样式要支持配置，宽高
// 修改命名：menu->node  path->code  route->children

var EditableSortableTree = function EditableSortableTree(props) {
  var _props$treeData = props.treeData,
      treeDataTemp = _props$treeData === void 0 ? [] : _props$treeData,
      treeNodeFormAPI = props.treeNodeFormAPI,
      FormComponent = props.FormComponent,
      _props$leftWidth = props.leftWidth,
      leftWidth = _props$leftWidth === void 0 ? 40 : _props$leftWidth,
      getTreeData = props.getTreeData,
      onChange = props.onChange,
      needClear = props.needClear;

  if (!(typeof leftWidth === 'number' && leftWidth > 0 && leftWidth < 100)) {
    // console.log('33 props', 'leftWidth属性必须是(0, 100)之间的数字');
    throw new Error('Property leftWidth must be a number between (0, 100)');
  } // console.log('23 props', props);
  // 对菜单树数据，做一些处理


  var treeData = handleRouteData(treeDataTemp);

  var _useState = React.useState(treeData),
      _useState2 = _slicedToArray(_useState, 2),
      menuTreeData = _useState2[0],
      setMenuTreeData = _useState2[1];

  var _useState3 = React.useState(treeData),
      _useState4 = _slicedToArray(_useState3, 2),
      menuTreeDataBeforeModified = _useState4[0],
      setMenuTreeDataBeforeModified = _useState4[1];

  var _useState5 = React.useState({}),
      _useState6 = _slicedToArray(_useState5, 2),
      currentNodeContent = _useState6[0],
      setCurrentNodeContent = _useState6[1]; // isTreeUnderEditing: Tree组件是否出在正在编辑的状态
  // 如果Tree组件处于正在编辑状态，则Tree组件的节点不可拖动


  var _useState7 = React.useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      isTreeUnderEditing = _useState8[0],
      setTreeUnderEditing = _useState8[1]; // todo: 从封装划分和开闭原则来说 应该放在 可编辑树组件中，后续优化
  // todo: 要将currentSelectNode命名改为：currentSelectNodeId更准确一些


  var _useState9 = React.useState(''),
      _useState10 = _slicedToArray(_useState9, 2),
      currentSelectNode = _useState10[0],
      setCurrentSelectNode = _useState10[1]; // 正在编辑名称的菜单节点


  var _useState11 = React.useState(''),
      _useState12 = _slicedToArray(_useState11, 2),
      editingNode = _useState12[0],
      setEditingNode = _useState12[1];

  var _Form$useForm = antd.Form.useForm(),
      _Form$useForm2 = _slicedToArray(_Form$useForm, 1),
      form = _Form$useForm2[0];

  var configProps = {
    form: form,
    isTreeUnderEditing: isTreeUnderEditing,
    setTreeUnderEditing: setTreeUnderEditing,
    currentSelectNode: currentSelectNode,
    setCurrentSelectNode: setCurrentSelectNode,
    currentNodeContent: currentNodeContent,
    setCurrentNodeContent: setCurrentNodeContent,
    editingNode: editingNode,
    setEditingNode: setEditingNode,
    menuTreeData: menuTreeData,
    setMenuTreeData: setMenuTreeData,
    treeNodeFormAPI: treeNodeFormAPI,
    FormComponent: FormComponent,
    leftWidth: leftWidth,
    onChange: onChange
  }; // 点击了弹框的取消按钮，初始化一些状态

  var closeModal = function closeModal() {
    // 关闭弹框时清除表单数据
    form.resetFields();
    treeNodeFormAPI === null || treeNodeFormAPI === void 0 ? void 0 : treeNodeFormAPI.resetFields(); // 关闭弹窗后要将一些状态进行初始化，否则再次打开弹窗容易出问题
    // 将菜单树数据 重置为空数组

    setMenuTreeData([]);
    setMenuTreeDataBeforeModified([]);
    setTreeUnderEditing(false); // setEditingNode清除 正在编辑中的节点

    setEditingNode(''); // 清除选中的菜单节点记录

    setCurrentSelectNode('');
  }; // 获取数组的的属性JSON


  if (getTreeData && 'current' in getTreeData) {
    getTreeData.current = function () {
      return new Promise(function (resole) {
        // 保存最终要返回的树数据
        var finalTreeData = null;
        form.validateFields().then(function (formData) {
          // console.log('61 formData', formData);
          // currentSelectNode 是当前树组件中选中的节点
          // console.log('62 currentSelectNode', currentSelectNode);
          var _formData$name = formData.name,
              title = _formData$name === void 0 ? '' : _formData$name; // console.log('83 menuTreeData', menuTreeData);
          // 最后提交时，将表单数据添加到对应的tree数据节点中

          recurse(menuTreeData, currentSelectNode, function (item, index, data) {
            data[index] = _objectSpread2(_objectSpread2(_objectSpread2({}, item), formData), {}, {
              key: currentSelectNode,
              title: title
            });
          }); // 将老、新菜单的多层树形JSON 转成 一层的List结构

          var oldMenuList = flatMenuData(lodash.cloneDeep(menuTreeDataBeforeModified)); // console.log('80 oldMenuList', oldMenuList);
          // 将当前编辑后的菜单数据深拷贝一份
          // console.log('70 menuTreeData', menuTreeData);
          // todo: 排查lodash 深拷贝函数有问题

          var newMenuData = JSON.parse(JSON.stringify(menuTreeData)); // console.log('72 newMenuData', newMenuData);
          // addMenuCodeToMenuNode(newMenuData);

          var newMenuList = flatMenuData(newMenuData); // console.log('88 newMenuList', newMenuList);
          // 老菜单的id列表(有menuId的节点是从后端返来的)

          var oldMenuIdList = oldMenuList.filter(function (menu) {
            return !!menu.menuId;
          }).map(function (_ref) {
            var menuId = _ref.menuId;
            return menuId;
          });
          var newMenuIdList = newMenuList.filter(function (menu) {
            return !!menu.menuId;
          }).map(function (_ref2) {
            var menuId = _ref2.menuId;
            return menuId;
          }); // console.log('46 oldMenuIdList', oldMenuIdList);
          // console.log('47 newMenuIdList', newMenuIdList);
          // 新的菜单列表中，如果菜单节点没有menuId，说明是新增的节点

          var addedMenuIdList = newMenuList.filter(function (menu) {
            return !menu.menuId;
          }); // 被删除的菜单的id列表

          var deletedMenuIdList = []; // 被修改的菜单的id列表

          var modifiedMenuIdList = []; // 老新菜单交集部分的菜单id列表，这个交集的用途主要是对比这些节点有没有别改动

          var intersectionMenuIdList = []; // 找出被删除的菜单id列表 和 交集部分菜单的id列表

          oldMenuIdList.forEach(function (oldMenuId) {
            // 老菜单树中的菜单id在新菜单列表中不存在了，说明该老菜单节点被删除
            if (!newMenuIdList.includes(oldMenuId)) {
              deletedMenuIdList.push(oldMenuId);
            } else {
              // 老菜单树中的菜单id在新菜单列表中还存在了，这个节点就是老新菜单树中共有的交集部分
              intersectionMenuIdList.push(oldMenuId);
            }
          }); // console.log('59 add', addedMenuList);
          // console.log('60 intersectionMenuIdList', intersectionMenuIdList);
          // 老新交集部分中的 老菜单的id与该老菜单节点的映射关系

          var oldMenuMap = {};
          intersectionMenuIdList.forEach(function (intersectionMenuId) {
            oldMenuList.forEach(function (oldMenu) {
              if (oldMenu.menuId === intersectionMenuId) {
                oldMenuMap[intersectionMenuId] = oldMenu; // oldMenuMap.push({ [intersectionMenuId]: oldMenu });
              }
            });
          }); // 老新交集部分中的 新菜单的id与该新菜单节点的映射关系

          var newMenuMap = {};
          intersectionMenuIdList.forEach(function (intersectionMenuId) {
            newMenuList.forEach(function (newMenu) {
              if (newMenu.menuId === intersectionMenuId) {
                // newMenuMap.push({ [intersectionMenuId]: newMenu });
                newMenuMap[intersectionMenuId] = newMenu;
              }
            });
          }); // console.log('77 oldMenuMap', oldMenuMap);
          // console.log('78 newMenuMap', newMenuMap);

          try {
            // 对比老新菜单中交集的菜单每个是否被修改过
            intersectionMenuIdList.forEach(function (intersectionMenuId) {
              var isCurrentMenuModified = false;
              var currentOldMenu = oldMenuMap[intersectionMenuId];
              var currentNewMenu = newMenuMap[intersectionMenuId];
              var keysLengthOfOldMenu = Object.values(currentOldMenu).filter(function (value) {
                return !!value;
              }).length;
              var keysLengthOfNewMenu = Object.values(currentNewMenu).filter(function (value) {
                return !!value;
              }).length; // console.log('84 keysLengthOfOldMenu', keysLengthOfOldMenu);
              // console.log('85 keysLengthOfNewMenu', keysLengthOfNewMenu);

              if (keysLengthOfOldMenu !== keysLengthOfNewMenu) {
                // 如果当前菜单老节点和新节点中的 非空属性数量不同，则说明被修改过了
                isCurrentMenuModified = true;
              } else {
                Object.keys(currentOldMenu).forEach(function (key) {
                  if (_typeof(currentOldMenu[key]) !== 'object' && _typeof(currentNewMenu[key]) !== 'object' && currentOldMenu[key] !== currentNewMenu[key]) {
                    // console.log('95 intersectionMenuId', intersectionMenuId);
                    // console.log('96 currentOldMenu', currentOldMenu[key]);
                    // console.log('97 currentNewMenu', currentNewMenu[key]);
                    // 如果菜单节点中当前的字段是简单类型，但却不相等，则说明该节点被修改过了
                    isCurrentMenuModified = true;
                  } else {
                    // 如果菜单节点中当前的字段是对象类型，深层对比是否相等来判断是否被修改过
                    isCurrentMenuModified = !lodash.isEqual(currentOldMenu[key], currentNewMenu[key]);
                  }

                  if (isCurrentMenuModified) {
                    // console.log('113 intersectionMenuId', intersectionMenuId);
                    // 如果当前菜单节点被修改过了，则将改菜单的id加到被修改的菜单id的list中
                    modifiedMenuIdList.push(intersectionMenuId);
                  }
                });
              }
            });
          } catch (error) {
            console.log('159 error', error);
          } // console.log('133 add', addedMenuIdList);
          // console.log('134 delete', deletedMenuIdList);
          // console.log('135 oldMenuMap', oldMenuMap);
          // console.log('136 newMenuMap', newMenuMap);
          // console.log('137 modifiedMenuIdList', modifiedMenuIdList);
          // 菜单节点id与该菜单节点的操作类型的映射关系


          var menuIdAndOperationMap = {};
          addedMenuIdList.forEach(function (menuId) {
            menuIdAndOperationMap[menuId] = 'add';
          });
          deletedMenuIdList.forEach(function (menuId) {
            menuIdAndOperationMap[menuId] = 'delete';
          });
          modifiedMenuIdList.forEach(function (menuId) {
            menuIdAndOperationMap[menuId] = 'modify';
          }); // console.log('178 menuIdAndOperationMap', menuIdAndOperationMap);

          /**
           * 节点的operation标识暂时也其实没用到，可有可无，暂时保留相关逻辑，以备后需
           * 关于节点的operation标识：本意是前端带上这个操作的标识，是为了告诉后端每个节点的操作类型，方便后端处理
           * 但前端在这块的逻辑处理上并不是十分可靠，尤其是新老菜单交集部分的菜单节点是否有被修改过，对比很麻烦且不准确
           * 再加之实际上后端无需这个标识也能准确判定节点的处理，目前后端的判定和处理逻辑如下：
           *    1、新增：节点没有menuId，就认为是新节点，新增一条记录去存；
           *    2、修改：节点有menuId，就认为是已有的节点，后端不管前端有没有修改这个节点的信息，直接更新覆盖这条记录；
           *    3、删除：前端将删除的节点的id放进数组deletedNodeList，并传给后端，后端将这些id的记录做逻辑删除处理。
           */
          // 递归处理将 每个节点的操作标识operation添加到该节点中(表明该节点的操作类型：新增add/删除delete/修改modify)

          var addOperationToEveryNode = function addOperationToEveryNode(menuData) {
            menuData.forEach(function (menuNode) {
              var menuId = menuNode.menuId,
                  children = menuNode.children;
              menuNode.operation = menuIdAndOperationMap[menuId] ? menuIdAndOperationMap[menuId] : '';

              if (Array.isArray(children) && children.length) {
                addOperationToEveryNode(children);
              }
            });
          };

          addOperationToEveryNode(newMenuData);
          /**
           * finalMenuListDataToBackEnd是菜单多层JSON扁平化后端的一层数组，最后没有用到，由来如下：
           * 刚开始考虑前后端数据交互格式，有两种可选方案：
           * 1、前端把树形的菜单扁平化一层list，list中包含新老菜单树中的所有节点，并会在每个节点中带有oparation操作标识，后端直接去按照list存成数据库记录即可；
           * 2、前端直接将多层树形JSON传给后端，后端自己用逻辑去处理节点直接的层级关系，并转成一层list去存库。
           * 最后采用方案2，所以finalMenuListDataToBackEnd这个list没有用到，暂时还保留这块处理逻辑，以备可能后用
           */

          var finalMenuListDataToBackEnd = lodash.cloneDeep(oldMenuList);
          addedMenuIdList.forEach(function (addedMenuId) {
            // console.log('154 addedMenuId', addedMenuId);
            // 将新增的节点添加进去
            newMenuData.forEach(function (menuNode) {
              var menuId = menuNode.menuId;

              if (menuId === addedMenuId) {
                // console.log('158 addedMenuId', addedMenuId);
                finalMenuListDataToBackEnd.push(menuNode);
              }
            });
          }); // 为每个节点添加operation操作标识

          addOperationToEveryNode(finalMenuListDataToBackEnd); // console.log('246 finalMenuListDataToBackEnd', finalMenuListDataToBackEnd);
          // console.log('247 newMenuData', newMenuData);

          modifySomePropertyNameInTreeData(newMenuData); // 拿出根路由的子路由数组（里面都是一级菜单）

          var routeWithoutRootNode = lodash.cloneDeep(newMenuData[0].routes); // console.log('251 routeWithoutRootNode', routeWithoutRootNode);

          delete newMenuData[0].routes; // 将根路由 和 一级路由 都放在第一级

          var finalRouteData = [newMenuData[0]].concat(_toConsumableArray(routeWithoutRootNode));
          finalTreeData = {
            treeData: finalRouteData,
            deletedNodeList: deletedMenuIdList
          }; // console.log('256 finalTreeData', finalTreeData);
          // console.log('258 menuList', JSON.stringify(menuList));
          // 向后端提交最终的 菜单树形数据
          // const success = await dispatch({
          //   type: 'dynamicMenuModel/saveMenuData',
          //   payload: menuParams,
          // });
          // console.log('282 success', success);
          // 关闭弹框后需要清除一些状态

          if (needClear) {
            closeModal();
          }

          return resole(finalTreeData);
        })["catch"](function (info) {
          console.log('Right form validation failed: ', info);
        });
      });
    };
  }

  return /*#__PURE__*/React__default["default"].createElement("div", null, /*#__PURE__*/React__default["default"].createElement(DynamicMenuConfig, configProps));
};

exports["default"] = EditableSortableTree;
exports.handleRouteData = handleRouteData;
exports.trimNull = trimNull;
